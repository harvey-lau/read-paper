# The Intensive Reading of 2022-[*LibAFL: A Framework to Build Modular and Reusable Fuzzers*](https://dl.acm.org/doi/abs/10.1145/3548606.3560602)

## 0x01 The Abstract of Fuzzers

- The **Input** is the internal representation of the program input (or part of it).
- The **Corpus** is a storage for inputs and their associated metadata.
- The **Scheduler** is a  component tied with the corpus.
- The **Stage** is a component defining an action to perform on a single test case from the corpus.
- The **Observer** is an entity that provides information from a single execution of the target.
- The **Executor** is the component responsible to execute the target system given an input from the fuzzer.
- The **Feedback** is an entity that classifies the outcome of an execution of the program under test as interesting or not.
- The **Mutator** is an entity that takes one or more Inputs and generates a new derived one.
- The **Generator** is an component designed to generate a new Input from scratch.

You can find a more systematical and formal definition in [*The Art, Science, and Engineering of Fuzzing: A Survey*](https://ieeexplore.ieee.org/document/8863940).

## 0x02 The Design of LibAFL

- **LibAFL Core** is the main library and contains the fuzzing components and their implementations.
- **LibAFL Targets** contains the code that lives within the target program, like the runtime library for coverage tracking.
- **LibAFL CC** provides the functionalities to write compiler wrappers for LibAFL, by providing a set of compiler extensions useful for instrumentation to users.

![2022-libafl-fig1.png](https://github.com/harvey-lau/read-paper/2-spt/figures/2022-libafl-fig1.png)

- The **State** is where all the non-volatile data resides.
- The **Fuzzer** is a recipient for the operations that define what the fuzzer can do.
- The **Events Manage** is an interface for generating and processing events, which can be used to implement multi-node synchronization in a parallel fuzzer or simply for the purpose of logging.

## 0x03 Experiments

4 problems:

- Roadblocks bypassing
- Structure-aware fuzzing
- Corpus scheduling
- Energy assignment

3 sets of experiments:

- The performance in terms of code coverage and bug detection of several approaches.
- The combination of orthogonal approaches.
- The efficiency in a traditional context.

### 1. Bypassing Roadblocks

Ready-to-use techniques:

- The value-profile proposed by LibFuzzer.
- The cmplog from AFL++.
- The autotokens from AFL++.

The 4 legends in Table 2:

1. plain: autotokens
2. value_profile: autotokens + value-profile
3. cmplog: autotokens + cmplog
4. value_profile_cmplog: autotokens + value-profile + cmplog

Results (**uncovered** code coverage):

- bloaty_fuzz_target: 1 > 4 > 3 > 2
- lcms-2017-03-21: 1 > 4 > 2 > 3
- libpcap_fuzz_both: 2 > 3 > 1 > 4
- mbedtls_fuzz_dtlsclient: 2 > 1 > 3 > 4
- sqlite3_ossfuzz: 1 > 3 > 2 > 4

### 2. Structure-aware Fuzzing

Ready-to-use techniques:

- Mautilus, a grammar-based coverage-guided fuzzer that evolves a corpus of syntax trees with mutation like subtree generation and replacement from another input in the corpus.
- Gramatron, a grammar-based fuzzer that employs a grammar-to-automata conversion to implement fast mutators.
- Grimoire, a fuzzer that uses the portion of inputs that induced the novelty in coverage as tokens to build generalized "tree-like" inputs and perform grammar-like mutations.
- Grimoire also employs token-level fuzzing, an approach based on token extraction with a lexer.

The authors used Nautilus to generate 4096 initial inputs for these two fuzzers to avoid a bias due to the quality of the seed corpora provided by FuzzBench.

Table 3 is unclear because the paper doesn't explain 4 legends explicitly. Therefore, I guess:

- C-nautilus: original Nautilus.
- A-gramatron: original Gramatron with 4096 initial inputs generated by Nautilus.
- B-grimoire: Grimoire with **feature-1** and 4096 initial inputs generated by Nautilus. The feature-1 means inducing the novelty in coverage as tokens to build generalized "tree-like" inputs and perform grammar-like mutations.
- D-grimoire: Grimoire with **feature-2** and 4096 initial inputs generated by Nautilus. The feature-2 means employing token-level fuzzing based on token extraction with a lexer.

Results (**uncovered** bugs):

- mruby-2018-05-23: C > A > D > B
- php_php-fuzz-execute: A > C > D > B
- libpcap_fuzz_both: C > A > D > B

Furthermore, the authors compare Nautilus to Nautilus + MOpt and confirm the highly target-dependent nature of MOpt.

### 3. Corpus Scheduling

Table 5 is similar to Table 1. The main difference between them is that corpus scheduling doesn't related to The combination of orthogonal approaches.

### 4. Energy Assignment

Table 6 is similar to Table 5.

### 5. Misc

- A Generic Bit-level Fuzzer: As shown in Table 7, LibAFL outperforms HonggFuzz, AFL++, and Entropic. The scores are 98.61, 96.65, 96.32, and 94.22 respectively.
- Differential Fuzing: As shown in Figure 2, LibAFL outperform NeoDiff.
- Third-party Applications: TLSPUFFIN, Tartiflette, and BANANAFZZ.
